README for the Dirac video codec
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

1. Executive Summary
~~~~~~~~~~~~~~~~~~~~

Dirac is an open source video codec. It uses a traditional hybrid video codec
architecture, but with the wavelet transform instead of the usual block transforms.
Motion compensation uses overlapped blocks to reduce block artefacts that
would upset the transform coding stage.

Dirac can code just about any size of video, from streaming up to HD and beyond,
although certain presets are defined for different applications and standards.
These cover the parameters that need to be set for the encoder to work, such as
block sizes and temporal prediction structures, which must otherwise be set by
hand.

Dirac is intended to develop into real coding and decoding software, capable of
plugging into video processing applications and media players that need 
compression. It is intended to develop into a simple set of reliable but effective 
coding tools that work over a wide variety of content and formats, using well-understood
compression techniques, in a clear and accessible software structure. It is not intended 
as a demonstration or reference coder.


2. Documentation
~~~~~~~~~~~~~~~~

A user guide and a guide to the software is in progress. More details on running
the codec can be found at http://www.bbc.co.uk/rd/projects/dirac.


3. Building and installing
~~~~~~~~~~~~~~~~~~~~~~~~~~

  GNU/Linux, Unix, MacOS X, Cygwin, Mingw
  ---------------------------------------
     ./configure
     make
     make install

  The INSTALL file documents arguments to ./configure such as
  --prefix=/usr/local (specify the installation location prefix).

  Microsoft Visual C++
  --------------------
  The MSVC build uses nmake (make sure nmake.exe and lib.exe are in the PATH).
     cd win
     nmake /f Makefile

  Libraries and executables are created in the win directory.


4. Running the example programs
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

4.1 Command-line parameters

At the moment there is a very simple command-line parser class which is 
used in all the executables. The general procedure for running a program
is to type:

  prog_name -<flag_name> flag_val ... param1 param2 ...

In other words, options are prefixed by a dash and all options take values.
This includes boolean options. Parameters (like filenames) are not prefixed 
by a dash. We hope to fix this and support boolean options properly soon.

4.2 File formats

The example coder and decoder use a temporary file format which consists of
raw 8-bit planar YUV data together with a header file. This means that data
is stored bytewise, with a frame of Y followed by a frame of U followed by
a frame of V, all scanned in the usual raster order. The header records the
picture dimensions, which are taken to be those of the luminance or Y
component, and other metadata. The other metadata consists of the chroma
format, the frame rate in Hertz, a flag indicating interlace and, if interlace,
a flag indicating whether the interlace is top-field first. The interlace flags
are currently ignored as no special coding tools have been developed. The chroma
format setting records whether the video is sampled 4:4:4, 4:2:2, 4:1:1 or 4:2:0,
and is essential. The frame rate setting is used to calculate bit-rate for the
encoder, and display rate for the decoder, and if omitted a rate of 12Hz is assumed.

Raw YUV is commonly used in video codec standardisation processes, although
the chroma format is often restricted to 4:2:0. The provision of an additional
header file is unusual, however. For this reason the make_header tool is provided.
This writes a header file with the appropriate parameters input from the command
line.

Example.
  Write a header to accompany a raw data file test.yuv. The video has
  dimensions 352 x 288 pixels x 260 frames long, is in 4:2:0 format and not
  interlaced, and has a frame-rate of 15Hz.

  Solution
    make_header -xl 352 -yl 288 -zl 260 -cformat format420 -framerate 15 -interlace false output

  This writes test.hdr with the corresponding parameters.

Viewing and playback utilities for uncompressed video include MPlayer and
ImageMagick's display command.

  Continuing the 352x288 4:2:0 example above, to display a single frame
  with ImageMagick use the following.  Use <spacebar> to see subsequent frames.

    display -size 352x288 test.yuv

  To playback the uncompressed video use the following MPlayer command:

    mplayer -fps 15 -rawvideo on:size=152064:w=352:h=288 test.yuv

  (at the time of writing MPlayer could not playback 4:2:2 or 4:4:4 YUV data)

To generate uncompressed video in a suitable format for encoding with Dirac,
use the transcode utility (see http://zebra.fh-weingarten.de/~transcode/).

  This example uses a 720x576x50 DV source, and transcodes to 720x576 YUV in
  4:2:0 chroma format.  Note that cascading codecs (DV + Dirac) is a bad idea.

    transcode -i source.dv -x auto,null --dv_yuy2_mode -k -V -y raw,null -o test.avi
    tcextract -i test.avi -x rgb > test.yuv

    make_header -xl 720 -yl 576 -zl 50 -cformat format420 -framerate 25 -interlace false test


4.3 Encoding

There are a large number of parameters that can be used to run the encoder,
all of which are listed below, and which are set using the same conventions
as for make_header. However, things are simplified by using presets
for different applications. These set such things as block sizes and overlaps
for motion estimation and compensation (the codec used overlapped blocks),
and psychovisual weighting. They also define the context in which other parameters
like quality factors, operate. The presets are:

stream 	: for CIF and QCIF video
SD576	: for standard definition video
HD720p	: for 1280x720 High Definition progressive video
HD1080	: for 1920/1440x1080 High Definition progressive video [not yet supported]

The other useful parameter is the quality factor qf. This reduces quality the larger
the value, and qf=30 gives moderate quality video.

Simple coding example. Code an SD sequence to high quality.

Solution.

  dirac_encoder -SD576 true -qf 20 test test_out

will read test.yuv and test.hdr as input, and output a compressed bitstream test_out.drc
as well as locally-decoded files test_out.yuv and test_out.hdr.

Other parameters.

verbose		: turn on verbosity (if you don't, you won't see the final bitrate!)
L1_sep		: the separation between L1 frames (frames that are predicted but also
			used as reference frames, like P frames in MPEG-2)
num_L1		: the number of L1 frames before the next intra frame
xblen		: the width of blocks used for motion compensation
yblen		: the height of blocks used for motion compensation
xbsep		: the horizontal separation between blocks. Always <xblen
ybsep		: the vertical separation between blocks. Always <yblen
cpd		: normalised viewing distance parameter, in cycles per degree.
Iqf		: quality factor for Intra frames
L1qf		: ditto for L1 frames
L2qf		: ditto for remaining frames

Modifying L1_sep and num_L1 allows for new GOP structures to be used, and should be
entirely safe. There are two non-GOP modes that can also be used for encoding: 
setting num_L1=0 gives I-frame only coding, and setting num_L1<0 will produce
a sequence with infinitely many L1 frames i.e. with a single I frame at the
beginning of the sequence. 

Modifying the block parameters is strongly deprecated: it's likely
to break the encoder as there are many constraints. Modifying cpd will not break
anything, but will change the meaning of the various quality factors and will need
each of Iqf, L1qf and L2qf set experimentally. Setting Iqf, L1qf and L2qf directly
is very possible, and may be suitable for some sequences.

NB: qf, Iqf etc are not really a quality factor, but rate-distortion trade-off
parameters, and so setting them to particular values doesn't guarantee a given
quality.

Block separations must currently be set so that an integral number of macroblocks fits
into the frame horizontally and vertically. A macroblock is a 4x4 set of blocks,
so 4xblen must divide the frame width and 4yblen the frame height. 

4.4 Decoding

Decoding is much simpler. Just point the decoder input at the bitstream and the
output to a file:

  dirac_decoder -verbose true test_enc test_dec

will decode into test_dec.{yuv,hdr} with running commentary.

Thomas Davies
(dirac@rd.bbc.co.uk)
